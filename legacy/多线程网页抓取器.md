# å¤šçº¿ç¨‹ç½‘é¡µæŠ“å–å™¨

äºŒä¸‰æœˆåœ¨çŸ¥ä¹ä¸Šçœ‹äº†[åµ©å“¥](https://www.zhihu.com/question/356351510/answer/988891356)
çš„å›ç­”ï¼Œé‚æœ‰äº†å°è¯•å¯¹å…¶å…¥é—¨ç»ƒä¹ è¿›è¡Œå®ç°ï¼Œåªåšäº†ä¸€ä¸ç‚¹çš„å·¥ä½œæ„Ÿè§‰å°±æŒºåƒåŠ›ï¼Œå¯¹webï¼Œæ“ä½œç³»ç»ŸåŠCå¯¹æŒæ¡å¤ªæ¬¡äº†ï¼Œç¢°åˆ°ç‚¹å°é—®é¢˜å°±ä¼šå¡å¾ˆä¹…ï¼Œ ç´¢æ€§ä¹Ÿç¨å¾®çœ‹äº†çœ‹httpæŠ“åŒ…çš„ä¸€äº›è§†é¢‘èµ„æºï¼Œç½‘ç»œç¼–ç¨‹çš„ä¹¦ç±ï¼Œ åé¢å¿™äº›åˆ«çš„åˆæç½®äº†ã€‚
ç°åœ¨å›å¤´çœ‹ï¼Œåµ©å“¥çš„æ€»ç»“ä»ç„¶æ˜¯ååˆ†æ·±åˆ»ï¼Œæˆ–è®¸æˆ‘è¯¥æ£€è®¨æ£€è®¨è‡ªå·±çš„å­¦ä¹ æ–¹æ³•
>æœ‰ç›®çš„çš„ç»ƒä¹ ï¼Œå°¤å…¶æ˜¯ä¸€ä¸ªå®Œæ•´çš„åº”ç”¨é—®é¢˜çš„è§£å†³ï¼Œæ˜¯å­¦ä¹ çš„ä¸äºŒæ³•é—¨ã€‚

## å•é¡µé¢æŠ“å–
`HTTP1.1`çš„`GET`è¯·æ±‚é¡»å¸¦ä¸Š`HOST`å­—æ®µ
ä¹‹å‰åœ¨bç«™çœ‹çš„ç›—ç‰ˆğŸ˜‚[é™¶è¾‰](http://www.taohui.org.cn/)
`HTTP2.0`ä¸»è¦ç‰¹æ€§æ˜¯å¤šè·¯å¤ç”¨ï¼Œ`HTTP3.0`åˆ™æ˜¯åœ¨ç½‘ç»œå±‚å¯¹`UDP`ä¼˜åŒ–çš„`QUICåè®®`
```C
#include <stdio.h> 
#include <string.h> // memset memcpy
#include <stdlib.h> // free exit
#include <unistd.h> // read write close

#include <sys/socket.h> // socket connect
#include <netinet/in.h> // sockaddr_in sockaddr
#include <netdb.h> // hostent gethostbyname

static void error(const char * msg) {perror(msg); exit(0);}

int main(int argc, char **argv)
{
    //const char *domain = strlen(argv[1]) > 0 ? argv[1] : "localhost";
    //const int port = atoi(argv[2]) > 0 ? atoi(argv[2]) : 80;
  	const char *domain = "news.baidu.com";
   	const int port = 80;

    int sock = socket(AF_INET, SOCK_STREAM, 0);
    if(sock < 0)
        error("Fail to opening socket");
    
    struct hostent *host = gethostbyname(domain);
    if(!host)
        error("No such host");
    
    struct sockaddr_in serv_addr;
    memset(&serv_addr, 0, sizeof(serv_addr));
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(port);
    memcpy(&serv_addr.sin_addr.s_addr, host->h_addr, host->h_length);
    
    if(connect(sock, (struct sockaddr *)&serv_addr, sizeof (serv_addr)) < 0)
        error("Fail to connect host");
    
    char request[BUFSIZ];
    // http/1.1 must have host field
    char *head = "GET / HTTP/1.1rn";
    sprintf(request, "%sHost: %s", head, domain);
    strcat(request, "rnrn");
    printf("Request info:n%sn", request);
    
	int bytes;
	size_t total = strlen(request);
	size_t sent = 0;
	do
	{
		bytes = (int)write(sock, request + sent, total - sent);
		if(bytes < 0)
			error("Error writing to sock");
		if(bytes == 0)
			break;
		sent += bytes;
	} while(sent < total);


    char response[BUFSIZ];
	memset(response, 0, sizeof(response));
    char *document = malloc(1 << 30);
    size_t len = 0;
    printf("Response: n");
	do
    {
        strcat(document, response);
        fprintf(stdout, "%sn", response);
        memset(response, 0, sizeof *response);
		bytes = (int)recv(sock, response, BUFSIZ, 0);
		if(bytes < 0)
            error("Error reading from sock");
		if(bytes == 0)
			break;
        len += bytes;
    }while(1);
    document[len] = '';
    

    FILE *fp = fopen("0000.html", "w");
    fprintf(fp, "%s", document);
    fclose(fp);
    close(sock);
    free(document);
    
    printf("Done!n");
    getchar();
    return 0;
}
```
å¯¹GETçš„å­—æ®µè¿˜ä¸æ˜¯å¾ˆç†Ÿæ‚‰ï¼Œ æœç‹çš„æ–°é—»é¡µæŠ“å–ä¸‹æ¥éƒ½æ˜¯ä¹±ç ï¼Œæ–°æµªã€è…¾è®¯ä¹Ÿæ˜¯é¢ï¼Œå°±ç™¾åº¦å‹‰å¼ºè¿˜è¡Œï¼Œ é™¤äº†ç™¾åº¦å…¨æ˜¯ipv6åœ°å€ã€‚ ä¸€äº›åŠ¨æ€åŠ è½½çš„é¡µé¢å†…å®¹ä¹ŸåŠ è½½ä¸å‡ºæ¥ï¼Œ åé¢æœ‰æœºä¼šå†æ•´å§ï¼Œç°åœ¨æ„Ÿè§‰è¿˜ä¸é‚£é‡è¦ã€‚

### è§£æURL
é€å­—ç¬¦è§£ææ„Ÿè§‰æœ‰ç‚¹éš¾åº¦ï¼Œç”¨æ­£åˆ™åŒ¹é…hrefå±æ€§ï¼Œregexçš„é€šé…ç¬¦è¿˜å†™ä¸æ˜ç™½ï¼Œé™¤äº†http(s)ï¼Œæœ‰çš„æ¿å—è§£æä¸ºåŸŸååç¼€ï¼Œæˆ–æ˜¯å†—ä½™çš„`//`å‰ç¼€,  è¿™é‡Œç”¨æ ‡å¿—ä½,`switch`è¿›è¡Œåˆ†å¼€å¤„ç†, è¿™é‡Œå‚è€ƒçš„[group match](https://stackoverflow.com/questions/2577193/how-do-you-capture-a-group-with-regex)
```C
#include <stdio.h>
#include <string.h> // memset memcpy
#include <stdlib.h> // free exit

#include <regex.h>    // regcomp regexec regfree
#include <limits.h>

char *fgetls(FILE *fp){
    // pointer locate to file end
    fseek(fp, 0L, SEEK_END);
    // total length of file.txt
    long length = ftell(fp);
    // reset pointer for file head
    rewind(fp);
    char *whole_text = calloc(1, length + 1);
    if(1 != fread(whole_text, length, 1, fp)){
        free(whole_text);
        fprintf(stderr, "fread failed"), exit(1);
    }
    return whole_text;
}

typedef enum{
    U_CHECKED,
    U_REDUNTANT_PREFIX,
    U_SUFFIX,
    U_INGNORE
}U_FLAG;

int url_check(char *url){
    char proto[5];
    memcpy(proto, url, 4);
    proto[5] = '';
    
    if(0 == strcmp(proto, "http")) return U_CHECKED;
    if('/' == proto[0]){
        if('/' == proto[1])
            return U_REDUNTANT_PREFIX;
        return U_SUFFIX;
    }
    return U_INGNORE;
}


int main(int argc, char **argv)
{

    FILE *fp = fopen("/Users/wcw/0000.html", "r");
    char *source = fgetls(fp);
    char * pattern = "href="([a-zA-z0-9%/?=.&-_#]+)"";
    
    size_t maxMatches = INT_MAX;
    size_t maxGroups = 2;
    
    regex_t regexCompiled;
    regmatch_t groupArray[maxGroups];
    
    if (regcomp(&regexCompiled, pattern, REG_EXTENDED))
    {
        printf("Could not compile regular expression.n");
        return 1;
    };
    
    
    char *cursor = source;
    for (size_t m = 0; m < maxMatches; m++)
    {
        if (regexec(&regexCompiled, cursor, maxGroups, groupArray, 0))
            break;  // No more matches
        
        
        size_t offset = 0;
        for (size_t g = 0; g < maxGroups; g++)
        {
            if (groupArray[g].rm_so == (size_t)-1)
                break;  // No more groups
            
            if (g == 0)
                offset = groupArray[g].rm_eo;
            
            
            char domain[BUFSIZ] = "news.baidu.com";
            char cursorCopy[strlen(cursor) + 1];
            strcpy(cursorCopy, cursor);
            cursorCopy[groupArray[g].rm_eo] = 0;
            char *url = cursorCopy + groupArray[g].rm_so;
            if(g == 1){
                switch(url_check(url)){
                    case U_INGNORE: break;
                    case U_CHECKED: strcpy(domain, url); break;
                    case U_SUFFIX: strcat(domain, url); break;
                    case U_REDUNTANT_PREFIX: strncpy(domain, url+2, strlen(url)-2);break;
                }
            fprintf(stdout, "%u:%sn", m, domain);
            }
        }
        cursor += offset;
    }
    free(source);
    regfree(&regexCompiled);
    fclose(fp);
    return 0;
}

```

ä»Šå¤©æ•´åˆäº†ä¸‹ï¼Œå“åº”æœ‰äº›å¡ï¼Œéœ€è¦æ”¹æ”¹`recv`å¾ªç¯çš„é€€å‡ºï¼Œ æ„Ÿè§‰å¾—æ”¹æ”¹åšå®¢é¡µé¢äº†

---
å¿™åˆ«çš„è¯¥é¡¹ç›®åˆæ‹–äº†å¥½ä¹…ï¼Œ æ¨¡æ‹Ÿç™»é™†ä¸ŠæŠ¥ç–«æƒ…çš„æ—¶å€™ï¼Œé¡ºä¾¿æ•´ç†äº†ä¸‹[requests.get](https://wuchengwei.icu/archives/537 "é“¾å‘requests.getçš„å›ºå®šé“¾æ¥")ï¼Œ æ’äº†éƒ¨åˆ†`bug`ï¼Œ å¶å°”ä¼šæœ‰`incorrect checksum`çš„`malloc bug`,  è¿˜çœ‹ä¸å¤ªæ˜ç™½

---
`realloc`æ„Ÿè§‰è¿˜æ˜¯å¾—æ…ç”¨ï¼Œ `regex`åŒ¹é…æ—¶ä¼šæ£€æµ‹åˆ°`malloc`çš„ä¿®æ”¹ï¼Œä¹‹å‰`realloc`çš„åˆ¤å®šæ¡ä»¶å¯èƒ½å¹¶ä¸å®Œå…¨å‡†ç¡®ï¼Œ `socket`çš„å†™æ“ä½œä¸åƒ`python`ä¸­æ˜¯å›ºå®šå¤§å°ï¼Œ å¯èƒ½å°äºæŒ‡å®šçš„æ¥å—å­—èŠ‚å¤§å°ï¼Œ `while`çš„`recv`æ“ä½œé€€å‡ºæ¡ä»¶è¿˜æ˜¯çš„æ¥å—`buffer`é•¿åº¦ä¸º0ï¼Œ ä¸ç©¿å‡ºé—­åŒ…å¤–çš„ä¸´æ—¶å†…å­˜å¯ä»¥ä½¿ç”¨`alloca`ï¼Œ å†…åµŒçš„é—­åŒ…å¹¶ä¸å½±å“

---
ç°åœ¨çš„2`web`ï¼Œ`tls`å·®ä¸å¤šæ˜¯æ ‡é…äº†ï¼Œå…¼å®¹ä¸€äº›æ— éœ€åŠ å¯†çš„`http`ï¼Œ é¡µé¢çš„æŠ“å–éœ€è¦è€ƒä¸¤ç§æƒ…å†µï¼Œ`tls`å¼€æºåº“é€‰çš„æ˜¯`openssl`ï¼Œè‡ªæµ‹ä¹Ÿéœ€è¦[è¯ä¹¦]`https://www.jianshu.com/p/1de38a3f50f3`ï¼Œ çˆ¬è™«ä¸»è¦æ˜¯å®¢æˆ·ç«¯ï¼Œ éœ€è¦çš„æ˜¯`cert.pem`ï¼Œ å¯¹æœåŠ¡ç«¯è¿˜éœ€è¦å¯†é’¥`key.pem`,   æœ‰æœºä¼šä¹Ÿæƒ³è‡ªå·±å®ç°ä¸ªä»…å…·å¤‡åŸºæœ¬åŠŸèƒ½`tls`ï¼Œ äº†è§£ä¸‹ç»†èŠ‚ã€‚
`http://investors.sohu.com/`è¿”å›å“åº”å®Œæ¯•åè¿æ¥æœªæ–­å¼€ï¼Œè¿›ç¨‹ä¸€ç›´é˜»å¡ï¼Œ éœ€è¦åŠ å…¥ä¸€ä¸ªå®šæ—¶å™¨ï¼›
æƒ³å¤ç”¨`tls`ä¸‹å¯¹`ssl_write`ä¸`write`å‡½æ•°ï¼Œ ç­¾å­—ä¸åŒï¼Œ æœ‰ç‚¹éš¾æ•´ï¼Œ éƒ½æ˜¯`bug`
### å‚è€ƒ
[[1] https://github.com/ChenyuGao/Crawler-Parallel](https://github.com/ChenyuGao/Crawler-Parallel)

<!-- 2020å¹´6æœˆ14æ—¥ 21:30 -->